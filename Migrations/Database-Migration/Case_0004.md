

# ğŸ“Œ Case #4: MySQL â†’ Vitess

**Real company: YouTube (Google)**

Vitess was **created by YouTube** because **plain MySQL broke at scale**.
This is not a migration story â€” itâ€™s a *birth story*.

If you understand this case, you understand **database scalability at FAANG level**.

---

## 1ï¸âƒ£ Original Setup

### Company

**YouTube (Google)**

### Initial Database

**MySQL**

### Why MySQL Was Chosen

* Reliable OLTP
* Simple replication
* Familiar SQL
* Worked well for early growth

### Early Architecture

```
Application
   â†“
MySQL Primary
   â†“
Read Replicas
```

At first:

* Videos metadata
* Users
* Comments
* Likes
* Subscriptions

Everything fit.

---

## 2ï¸âƒ£ The Breaking Point (Where MySQL Collapsed)

By explosive growth, YouTube hit **hard MySQL limits**.

### ğŸš¨ Real Problems

#### 1. Write Scalability

* Single primary per shard
* Vertical scaling maxed out
* Replication lag exploded

#### 2. Manual Sharding Hell

They tried:

* Shard by user_id
* App-level routing
* Hundreds of MySQL instances

Result:

* Massive operational complexity
* Human error during resharding
* Downtime during shard moves

#### 3. Cross-Shard Queries

* Joins across shards impossible
* Aggregations painful
* Reporting systems fragile

ğŸ’¥ **Key realization**

> â€œMySQL is fine. Managing MySQL at scale is the problem.â€

---

## 3ï¸âƒ£ Why Vitess?

### What is Vitess?

**Vitess = MySQL + Sharding Middleware**

It provides:

* Transparent sharding
* Connection pooling
* Query routing
* Online resharding
* MySQL compatibility

### Why Not Switch Databases?

| Option             | Why Rejected                         |
| ------------------ | ------------------------------------ |
| PostgreSQL         | Migration too risky at YouTube scale |
| NoSQL              | SQL joins still required             |
| App-level sharding | Already failed                       |

### Why Vitess Won

* Keep MySQL
* Remove sharding logic from app
* Centralize routing & resharding
* Battle-tested internally

ğŸ§  **Vitess later became CNCF & powers YouTube, Slack, GitHub, Shopify**

---

## 4ï¸âƒ£ Architecture Before vs After

### ğŸ”´ Before (Manual MySQL Sharding)

```
App
 â†“
Shard Router (Custom Code)
 â†“
MySQL Shard A / B / C
```

Problems:

* Routing logic in app
* Shard split = code changes
* High risk

---

### ğŸŸ¢ After (Vitess)

```
App
 â†“
VTGate (Query Router)
 â†“
VTTablet
 â†“
MySQL Shards
```

ğŸ§  VTGate:

* Parses SQL
* Routes queries
* Handles fan-out

ğŸ§  VTTablet:

* Manages MySQL instance
* Replication
* Health checks

---

## 5ï¸âƒ£ Code-Level Changes (Critical Insight)

### Original MySQL Query (Same as After!)

```sql
SELECT *
FROM videos
WHERE user_id = 123
AND visibility = 'PUBLIC';
```

ğŸ”¥ **App code does NOT change**

Vitess:

* Intercepts SQL
* Routes it to correct shard
* Merges results if needed

---

### Schema Change (Vitess Keyspace)

```sql
CREATE TABLE videos (
  video_id BIGINT,
  user_id BIGINT,
  title TEXT,
  visibility TEXT,
  PRIMARY KEY (user_id, video_id)
);
```

### Sharding Definition (Vitess VSchema)

```json
{
  "videos": {
    "sharded": true,
    "vindexes": {
      "hash": {
        "type": "hash"
      }
    },
    "column_vindexes": [
      {
        "column": "user_id",
        "name": "hash"
      }
    ]
  }
}
```

ğŸ§  **This replaces app-level routing logic**

---

## 6ï¸âƒ£ Migration Strategy (How YouTube Did It)

### Step-by-Step (Production Reality)

1. Introduce Vitess **without sharding**
2. Migrate traffic gradually
3. Enable sharding
4. Reshard live traffic
5. Remove custom routing code

âš ï¸ Vitess supports **online resharding**
(no downtime, no app changes)

---

## 7ï¸âƒ£ Hidden Pitfalls (This Is Senior-Level Knowledge)

| Pitfall              | Reality               |
| -------------------- | --------------------- |
| Cross-shard joins    | Very expensive        |
| Fan-out queries      | Kill latency          |
| Bad shard key        | Permanent pain        |
| Transactions         | Limited across shards |
| Operational overhead | Vitess is complex     |

### Bad Query Example

```sql
SELECT COUNT(*)
FROM videos
WHERE visibility = 'PUBLIC';
```

ğŸš¨ This fans out to **all shards**.

---

## 8ï¸âƒ£ Final Outcome

### What Improved

âœ” Horizontal scalability
âœ” No app-level sharding logic
âœ” Online resharding
âœ” MySQL compatibility

### What Got Worse

âœ˜ More infrastructure
âœ˜ Steeper ops learning curve
âœ˜ Some queries need redesign

### When NOT to Use Vitess

* Small teams
* Small datasets
* No shard boundary
* Simple CRUD apps

---

## ğŸ¯ Interview Preparation Section

### Interview Question

> â€œHow does YouTube scale MySQL?â€

**Strong Answer**

> â€œBy using Vitess, which abstracts sharding, routing, and resharding away from the application while keeping MySQL semantics.â€

### Bonus Points

* VTGate
* VTTablet
* VSchema
* Online resharding

---

## ğŸ‘¨â€ğŸ’» Production Engineer Lessons

* Databases fail operationally before technically
* Sharding logic does not belong in app code
* SQL compatibility is priceless
* Resharding without downtime is a superpower

---

