
# ğŸ“Œ Case #2: MySQL â†’ PostgreSQL

**(Real company: Heroku)**

This is a **classic, real-world migration** that shows up **constantly in interviews** and **actually teaches production thinking**, not theory.

Heroku publicly standardized on **PostgreSQL** and gradually moved customers and internal systems **away from MySQL** as scale, correctness, and operability became more important than familiarity.

---
## 1ï¸âƒ£ Original Setup

### Company

**Heroku** (Salesforce subsidiary)

### Initial Database Choice: MySQL

**Why MySQL made sense early**

* Familiar to most engineers
* Fast for simple OLTP workloads
* Easy replication model
* Huge ecosystem of tools

**Early workload**

* CRUD-heavy web applications
* Simple relational models
* Moderate traffic
* Few complex queries

This mirrors **90% of startups**.

---

## 2ï¸âƒ£ The Breaking Point (Where MySQL Started Hurting)

As Heroku scaled multi-tenant platforms and internal services, problems surfaced.

### ğŸš¨ Pain Points

#### 1. Weak Transaction Semantics (Historically)

* Mixed engine usage (MyISAM vs InnoDB in older systems)
* Subtle bugs caused by inconsistent transaction guarantees
* Engineers *thought* they had ACID â€” sometimes they didnâ€™t

#### 2. Schema Changes at Scale

* `ALTER TABLE` locking behavior caused:

  * Long write blocks
  * Customer-visible latency spikes
* Online schema changes were painful and risky

#### 3. Advanced Querying & Constraints

* Limited constraint support compared to PostgreSQL
* Complex queries became:

  * Hard to reason about
  * Easy to accidentally break performance

#### 4. JSON & Semi-Structured Data

* MySQL JSON support arrived late and felt bolted-on
* PostgreSQLâ€™s JSONB was already mature and indexable

ğŸ’¥ **Key realization**:
MySQL was â€œgood enoughâ€ early â€” but correctness + operability were becoming more important than raw familiarity.

---

## 3ï¸âƒ£ Why PostgreSQL Won

### Requirements That Emerged

| Requirement               | Needed |
| ------------------------- | ------ |
| Strong ACID guarantees    | âœ…      |
| Online schema evolution   | âœ…      |
| Advanced indexing         | âœ…      |
| Rich constraints          | âœ…      |
| JSON + relational hybrid  | âœ…      |
| Predictable query planner | âœ…      |

### Why Not Stay on MySQL?

* Fixes existed, but **engineering effort shifted to fighting the DB**
* PostgreSQL solved these problems *natively*

### Why PostgreSQL?

* Strong transactional guarantees by default
* Better query planner for complex joins
* First-class JSONB support
* Extensions ecosystem (PostGIS, pg_stat_statements, etc.)
* Operational transparency

ğŸ§  **Production truth**:
PostgreSQL favors **correctness and explicitness**.
MySQL favors **speed and simplicity** â€” until complexity grows.

---

## 4ï¸âƒ£ Architecture Before vs After

### ğŸ”´ Before (MySQL)

```
App Servers
   â†“
 MySQL Primary
   â†“
 Read Replicas
```

Problems:

* App-level enforcement of constraints
* Careful manual query tuning
* Schema changes = scary

---

### ğŸŸ¢ After (PostgreSQL)

```
App Servers
   â†“
 PostgreSQL Primary
   â†“
 Read Replicas
   â†“
 Analytics / Admin Queries
```

Improvements:

* DB-level constraints
* Better isolation guarantees
* Safer migrations
* Cleaner app code

---

## 5ï¸âƒ£ Code-Level Changes (This Is Interview Gold)

### Example: User Orders Table

### MySQL Version

```sql
CREATE TABLE orders (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT,
  total_amount DECIMAL(10,2),
  status VARCHAR(20),
  created_at DATETIME
);
```

âš ï¸ Issues:

* No foreign key
* No timezone safety
* Weak data guarantees

---

### PostgreSQL Version

```sql
CREATE TABLE orders (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  total_amount NUMERIC(10,2) NOT NULL CHECK (total_amount >= 0),
  status TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

âœ” Constraints enforce correctness
âœ” Timezone-safe timestamps
âœ” Invalid data becomes **impossible**

---

### Query Difference (Important!)

**MySQL-style defensive query**

```sql
SELECT * FROM orders WHERE user_id = ? AND status = 'PAID';
```

**PostgreSQL-style confident query**

```sql
SELECT *
FROM orders
WHERE user_id = $1
AND status = 'PAID';
```

Why this matters:

* PostgreSQLâ€™s planner + constraints = fewer defensive checks
* Cleaner application logic

---

## 6ï¸âƒ£ Migration Strategy Used

### ğŸ§  Phased Migration (Production Safe)

1. **Schema-first**

   * Design PostgreSQL schema properly
   * Add constraints early

2. **Dual Writes**

   * App writes to MySQL + PostgreSQL
   * PostgreSQL initially read-only

3. **Backfill Historical Data**

   * Chunked exports
   * Ordered by primary key
   * Validation checks

4. **Read Switch**

   * Gradually move reads to PostgreSQL
   * Monitor latency and error rates

5. **Kill MySQL**

   * Remove dual writes
   * Archive MySQL data

âš ï¸ **Never big-bang for core DBs**

---

## 7ï¸âƒ£ Hidden Pitfalls (Real Engineer Warnings)

| Pitfall           | Reality                   |
| ----------------- | ------------------------- |
| MySQL NULL habits | PostgreSQL forces clarity |
| Implicit casts    | PostgreSQL is strict      |
| Index differences | Must redesign indexes     |
| ORMs              | Some ORM defaults break   |
| Query planner     | Needs ANALYZE & tuning    |

ğŸ’£ Many migrations fail because teams **donâ€™t respect PostgreSQLâ€™s strictness**.

---

## 8ï¸âƒ£ Final Outcome

### What Improved

âœ” Data correctness
âœ” Safer schema migrations
âœ” Better complex query performance
âœ” Cleaner app logic

### What Got Worse

âœ˜ Engineers had to *learn SQL properly*
âœ˜ Stricter DB rejected bad data
âœ˜ Some queries required rewrites

### When NOT to Do This

* Very simple CRUD apps
* Low traffic
* No joins or constraints
* Tiny team with zero DB expertise

---

## ğŸ¯ Interview Preparation Section

### Common Interview Question

> â€œWhy migrate from MySQL to PostgreSQL?â€

**Strong answer**

> â€œAs systems grow, correctness, constraints, and transactional guarantees matter more than convenience. PostgreSQL enforces these at the database level, reducing application complexity and production bugs.â€

### Follow-up You Should Mention

* Dual writes
* Schema-first migration
* Constraint-driven design
* Query planner differences

---

## ğŸ‘¨â€ğŸ’» Production Engineer Lessons

* Databases are **contracts**, not just storage
* Weak constraints push bugs into application code
* PostgreSQL shifts failures **left** (earlier)
* Migrations are *organizational changes*, not just technical ones

---

